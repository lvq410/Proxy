# 基本用法
tcp反向代理的实现为纯tcp数据转发

假设有请求者`A`，服务器`B`。`B`在`3306`端口上对外提供服务。但因为网络问题，`A`无法直接访问到`B`。

而此时如果有一个机器`C`，`A`可以访问到`C`，`C`也能访问到`B`，则可以在`C`上部署一个代理服务

该代理服务`C`在端口`33306`（随意配置的可用端口）上提供服务，将该端口收到的任何流量，都原封不动转发给`B:3306`，并将收到的数据原路返回

这就是tcp反向代理

这样`A`看起来访问的是`C:33306`，但其实是访问的`B:3306`

配置代码例
```
tcp:
- port: 33306
  target: B:3306
```

> 与`socks5`等代理协议比起来，tcp不支持请求者指定要访问的最终目标服务，因此tcp算是一种反向代理

# host绑定
因为一台机器可以有多个ip（或多个host名），因此启动服务端口时，可以指定该服务端口与哪个ip做绑定

此时请求者要访问该服务端口，必须使用绑定的ip

默认可以不配置（或配置成`0.0.0.0`），会将端口绑定在所在机器的所有ip上

假设机器`C`有两个IP：`C1`和`C2`，代理配置成
```
tcp:
- host: C1
  port: 33306
  target: B:3306
```

此时`A`就必须使用`C1:33306`来访问，而不能使用`C2:33306`

> 利用该方法，也可以在同一台机器上启动多个端口相同，但代理目标不同的tcp代理。<br>
> 当然，需要给该机器创建多个不同的ip
> 见：[windows创建虚拟ip](https://lvt4j.51vip.biz/confluence/display/ITNotes/Windows#heading-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4%E8%99%9A%E6%8B%9FIP)

# 转发时经由其他代理
默认地，代理服务`C`与`B`是直接连接，但也可以选择再经由一个新的代理服务及代理协议再与目标服务进行连接

这个功能可以看做是代理协议的客户端实现

如果请求者不支持各种代理协议时，可以起个出口走其他代理的tcp反向代理服务，来弥补

配置例
```
tcp:
- port: 33306
  target: B:3306
  proxy: socks5://proxy-server:1080
#  proxy: http://proxy-server:1080
#  proxy: pws://proxy-server:80
#  proxy: pwss://proxy-server:443
```

> 目前仅支持这三种代理协议

另可参考 [私有WebSocket](pws.md)
